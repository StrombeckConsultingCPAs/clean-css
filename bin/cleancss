#!/usr/bin/env node

var util = require("util");
var fs = require('fs');
var path = require('path');
var CleanCSS = require('../index');

var commands = require('commander');

commands
  .option('-v, --version', 'Print current version')
  .option('-e, --empty, --remove-empty', 'Remove empty declarations (e.g. a{})')
  .option('-b, --keepbreaks, --keeplinebreaks', 'Keep line breaks')
  .option('--s0', 'Remove all special comments (i.e. /*! special comment */)')
  .option('--s1', 'Remove all special comments but the first one')
  .option('-o [output-file]', 'Use [output-file] as output instead of stdout')
  .parse(process.argv);

var options = {
  source: null,
  target: null
};
var cleanOptions = {};
var fromStdin = !process.env['__DIRECT__'] && process.stdin.readable;

if (commands.version) {
  var packageConfig = fs.readFileSync(path.join(path.dirname(fs.realpathSync(process.argv[1])), '../package.json'));
  util.puts(JSON.parse(packageConfig).version);
  return 0;
}

if (commands.o)
  options.target = commands.o;
if (commands._)
  options.source = commands._[0];
if (commands.removeempty)
  cleanOptions.removeEmpty = true;
if (commands.keeplinebreaks)
  cleanOptions.keepBreaks = true;
if (commands.s1)
  cleanOptions.keepSpecialComments = 1;
if (commands.s0)
  cleanOptions.keepSpecialComments = 0;

if (options.source) {
  fs.readFile(options.source, 'utf8', function(error, text) {
    if (error) throw error;
    output(CleanCSS.process(text, cleanOptions));
  });
} else {
  var stdin = process.openStdin();
  stdin.setEncoding('utf-8');
  var text = '';
  stdin.on('data', function(chunk) {
    text += chunk;
  });
  stdin.on('end', function() {
    output(CleanCSS.process(text, cleanOptions));
  });
}

function output(cleaned) {
  if (options.target) {
    fs.writeFileSync(options.target, cleaned, 'utf8');
  } else {
    process.stdout.write(cleaned);
  }
};
